Firstly, there are 3 utilities functions on top of our cpp code, 2 of them are swap functions which created for both insertion and quick sorts. Then, a getMax() function is created for Radix Sort. 
The first sorting algorithm is Insertion Sort, which only takes 1 parameter, the vector. Pass in the vector and locate its first and last index.  While the i is not equal to 0 and a[i] is greater than a[j], we will keep swapping i and j, then reduce the index of i and j by 1. 

The second sorting algorithm is selection sort, takes only 1 parameter, the vector itself. Selection Sort will iterate from index 0 all the way to the last element of the vector while iterate through the index j and i, check if the element at index j is smaller than minimum. If the index j is smaller than minimum, then the element at index j will become new minimum. 
After finding the minimum element, the minimum element found will be swapped with i, which is known as the left-most unswapped element. This process will keep going until all the unswapped elements has been swapped. Based on this algorithm, it has to iterate through every single element to check if the element is smaller than another even if the input is pre-sorted. 

The third sorting algorithm is bubble sort, takes only 1 parameter as well, the vector itself. The function will swap the element j and j+1 only if the value of j is larger than j+1, similarly with selection sort, it has to iterate through every single element in the vector regardless of the condition of input. However, if the inputs are pre-sorted, no swaps are needed.

The next sorting algorithm is merge sort, which will take 3 parameters: the vector, index of left and right element. If the left element is greater than right element then return return, this usually happen when the sequence is only 1 which l = r. Then, the middle element will be calculated to divide the input into half to break down the problem into smaller subproblems recursively. At last, we will merge the input back while sorting it with the merge function, which it will check the size of left vector and right vector and compare the elements of both vectors to find the minimum elements and copy it into the result array. Then, move to the next elements and continue comparing until all elements are sorted. After that, two while loops will be used to check if there are any elements left at the end of left and right vectors. If there are elements in the end of left and right vectors, copy all the remaining elements in the original vector. 

The fifth sorting algorithm is quick sort. We have 3 types of quick sort: random pivot, first element as pivot, median element as pivot. For random pivot, the pivot will be choose using rand() function and swap the element with the first element in the vector, then call the partition function. For the first element as pivot, it's the most typical quick sort which choose the first element as pivot. For picking the median as pivot, it's almost similar with the random pivot because the median element will also be swapped with the first element in the vector and go through the partition function for sorting. The time complexity for quick sort is largely depends on the value of pivot. 

Moving on to heap sort, the way heap sort work is building a max heap tree, which the largest element in the vector will be on the top of the tree as root node after heapifying. Then, we will swap the last node with the root node and decrease the size of tree, so the root node that we swapped will be place into the result vector. The process will keep going until the heap tree is empty, which means the vector is sorted. 

The next sorting algorithm is counting sort which it counts the frequency of each element and cumulative sum of the total elements and place the elements in sorted order. Lastly, copy the sorted vector into the original array.

For radix sort, it uses counting sort as subroutine to sort the elements from the least significant digit to the most significant digits. 
 
The print function are not used because we only display the running time for each algorithm only. The default size we used for all sorting algorithms is 4000 only in this case because we already tested the algorithm for different sizes from 100 to 100,000 in question 3 and question 4.  

For each sorting algorithm, running time for 3 different conditions: random input, pre-sorted input, and reversed input are recorded for comparison based sorting algorithms. For counting sort and radix sort, the running time recorded is just input of multiple digits numbers.
    